
import {
  RATE_BELOW_1500,
  RATE_ABOVE_1500,
  THRESHOLD_RATE_CHANGE,
  RETAIL_CHARGE,
  RETAIL_CHARGE_THRESHOLD,
  TAX_RATE,
  TAX_THRESHOLD,
  KWTBB_RATE,
  DISCOUNT_TABLE,
  PANEL_WATTAGE,
  PEAK_SUN_HOURS,
  BATTERY_CAPACITY_KWH,
  EXPORT_RATE,
  SYSTEM_PRICING,
  BATTERY_COST_CASH,
  BATTERY_COST_CC
} from '../constants';
import { BillBreakdown, SimulationResult, PricingTier } from '../types';

/**
 * Calculates the base charge (tariff).
 * The rate is determined by the TOTAL monthly usage (Flat Rate Tier).
 * If total usage > 1500, the higher rate applies to ALL units.
 */
const calculateBaseCharge = (kwhToPrice: number, totalMonthlyUsage: number): number => {
  if (kwhToPrice <= 0) return 0;
  
  // Determine rate based on Total Monthly Usage
  const rate = totalMonthlyUsage > THRESHOLD_RATE_CHANGE 
    ? RATE_ABOVE_1500 
    : RATE_BELOW_1500;

  return kwhToPrice * rate;
};

/**
 * Helper to get the applicable discount rate (in RM) based on total usage.
 * Returns negative value or 0.
 */
const getDiscountRateRm = (totalKwh: number): number => {
  if (totalKwh <= 0) return 0;
  const block = DISCOUNT_TABLE.find(b => totalKwh >= b.min && totalKwh <= b.max);
  return block ? (block.discountSen / 100) : 0;
};

/**
 * Main function to calculate the full bill breakdown.
 */
export const calculateBill = (totalKwh: number, exportKwh: number = 0): BillBreakdown => {
  if (totalKwh <= 0 && exportKwh <= 0) {
    return {
      baseCharge: 0,
      retailCharge: 0,
      discount: 0,
      serviceTax: 0,
      kwtbb: 0,
      exportCredit: 0,
      exportUnits: 0,
      eeIncentiveAdjustment: 0,
      subtotal: 0,
      finalTotal: 0,
      units: 0
    };
  }

  // --- 1. Determine Shared Rates ---
  const discountRate = getDiscountRateRm(totalKwh);

  // --- 2. Calculate Full Bill Components ---
  // Pass totalKwh as the second argument to determine the tier for the whole bill
  const totalBaseCharge = calculateBaseCharge(totalKwh, totalKwh);
  const retailChargeTotal = totalKwh > RETAIL_CHARGE_THRESHOLD ? RETAIL_CHARGE : 0;
  const totalDiscount = totalKwh * discountRate; // Apply rate to full usage
  
  const subtotalTotal = totalBaseCharge + retailChargeTotal + totalDiscount;

  // --- 3. Calculate Service Tax (Split Logic) ---
  // Tax applies to the portion of the bill generated by usage > 600kWh.
  // Taxable Amount = (Subtotal for Total Usage) - (Subtotal for First 600kWh).
  // CRITICAL: The "Subtotal for First 600kWh" must use the SAME rates (Base Rate & Incentive)
  // as the total bill, because those rates are determined by the TOTAL monthly usage.

  let serviceTax = 0;

  if (totalKwh > TAX_THRESHOLD) {
    const kwhExempt = TAX_THRESHOLD; // 600
    
    // Base charge for the exempt portion, using the rate determined by TOTAL usage
    const baseExempt = calculateBaseCharge(kwhExempt, totalKwh);
    
    // Discount for the exempt portion, using the rate determined by TOTAL usage
    const discountExempt = kwhExempt * discountRate;
    
    // Retail charge is 0 for the first 600
    const retailExempt = 0; 
    
    const subtotalExempt = baseExempt + retailExempt + discountExempt;
    
    // Taxable amount is the difference
    const taxableAmount = subtotalTotal - subtotalExempt;
    
    serviceTax = Math.max(0, taxableAmount * TAX_RATE);
  } else {
    serviceTax = 0;
  }

  // --- 4. KWTBB (Renewable Energy Fund) ---
  // 1.6% of (Base + Discount) - before tax
  const kwtbbBase = totalBaseCharge + totalDiscount;
  const kwtbb = Math.max(0, kwtbbBase * KWTBB_RATE);

  // --- 5. Export Credit ---
  // Export Credit = Export Units * Rate (0.20)
  // This is a credit, so it reduces the bill.
  const exportCredit = exportKwh * EXPORT_RATE * -1; // Negative value for deduction

  // --- 6. EE Incentive Adjustment for Export ---
  // Formula: IF(new export=0, 0, IF(new export > new import, -EE Incentive, -new export * (EE Incentive / new import)))
  // Note: totalDiscount is the "EE Incentive" (negative value).
  let eeIncentiveAdjustment = 0;
  
  if (exportKwh === 0) {
    eeIncentiveAdjustment = 0;
  } else if (exportKwh > totalKwh) {
    eeIncentiveAdjustment = -totalDiscount; // Becomes positive
  } else {
    // totalKwh must be > 0 here because if totalKwh=0, exportKwh(>0) > totalKwh would catch above
    eeIncentiveAdjustment = -exportKwh * (totalDiscount / totalKwh);
  }

  // --- 7. Final Total ---
  let finalTotal = subtotalTotal + serviceTax + kwtbb + exportCredit + eeIncentiveAdjustment;
  
  // Logic Fix: Ensure Final Bill is not negative
  finalTotal = Math.max(0, finalTotal);

  return {
    baseCharge: totalBaseCharge,
    retailCharge: retailChargeTotal,
    discount: totalDiscount,
    serviceTax: serviceTax,
    kwtbb: kwtbb,
    exportCredit: exportCredit,
    exportUnits: exportKwh,
    eeIncentiveAdjustment: eeIncentiveAdjustment,
    subtotal: subtotalTotal,
    finalTotal: finalTotal, 
    units: totalKwh
  };
};

export const simulateSolar = (
  monthlyUsage: number, 
  daytimePercentage: number,
  panelCount: number,
  batteryCount: number
): SimulationResult => {
  // 1. Calculate D and N
  const D = monthlyUsage * (daytimePercentage / 100);
  const N = monthlyUsage * (1 - (daytimePercentage / 100));

  // 2. Calculate S (Solar Generation)
  // 620W panels = 0.62 kW
  // producing 0.62kwh per hour * 3.5 hours * 30 days
  const kwPerPanelHour = PANEL_WATTAGE / 1000;
  const S = panelCount * kwPerPanelHour * PEAK_SUN_HOURS * 30;

  // 3. Calculate B (Total Battery Capacity Throughput)
  // quantity * 12.87 * 30
  const B = batteryCount * BATTERY_CAPACITY_KWH * 30;

  // 4. Calculate R (Remaining Solar)
  const R = S - D;

  // 5. Calculate Battery In
  // Logic simplified: Max(0, Min(B, R))
  const batteryIn = Math.max(0, Math.min(B, R));

  // 6. Calculate Battery Out (Consumed during night)
  // Formula: IF(D>S, 0, IF(B>(S-D), S-D, B)) * 0.9
  const batteryOut = batteryIn * 0.9;

  // 7. Calculate Export
  // Logic: R - batteryIn.
  const exportRaw = Math.max(0, R - batteryIn);
  // Round export to integer as requested
  const exportKwh = Math.round(exportRaw);

  // 8. Calculate New Import
  // IF R < 0: MAX(0, N - batteryOut) - R
  // IF R >= 0: MAX(0, N - batteryOut)
  let newImportRaw = 0;
  if (R < 0) {
    // Note: batteryOut is 0 when R < 0
    newImportRaw = Math.max(0, N - batteryOut) - R; 
  } else {
    // Note: batteryOut reduces Night load
    newImportRaw = Math.max(0, N - batteryOut);
  }
  
  // Round new import to integer as requested
  const newImport = Math.round(newImportRaw);

  // 9. Calculate New Bill
  const originalBill = calculateBill(monthlyUsage, 0);
  const newBill = calculateBill(newImport, exportKwh);

  // Data for Charts
  // Solar Direct Use: Amount of Solar used directly by D.
  const solarDirect = Math.min(S, D);
  
  // Chart battery visualization
  const chartBattery = Math.min(batteryOut, N);

  return {
    originalBill,
    newBill,
    solarGenerationMonthly: S,
    solarUtilized: solarDirect,
    batteryDischarge: chartBattery,
    gridImport: newImport,
    monthlySavings: originalBill.finalTotal - newBill.finalTotal,
    demandDay: D,
    demandNight: N
  };
};

/**
 * Reverse calculate kWh from a target Bill Amount using Binary Search.
 * Accurate within +/- RM0.05
 */
export const getKwhFromBill = (targetBill: number): number => {
  if (targetBill <= 0) return 0;
  
  let low = 0;
  let high = 10000; // Reasonable max
  let mid = 0;
  let iterations = 0;

  while (low <= high && iterations < 50) {
    mid = (low + high) / 2;
    const bill = calculateBill(mid, 0).finalTotal;

    if (Math.abs(bill - targetBill) < 0.05) {
      return Math.round(mid);
    }

    if (bill < targetBill) {
      low = mid;
    } else {
      high = mid;
    }
    iterations++;
  }
  return Math.round(mid);
};

/**
 * Lookup system cost based on panel count and battery count.
 * Includes Three-Phase price adjustments.
 */
export const calculateSystemCost = (panels: number, batteries: number, phase: 'single' | 'three' = 'single') => {
  const tier = SYSTEM_PRICING.find(p => p.panels === panels);
  if (!tier) return null;

  let cashPrice = tier.cashPrice;
  let ccPrice = tier.ccPrice;
  let inverterSize = tier.inverterSize;

  // Three Phase Logic Adjustments
  if (phase === 'three') {
    if (panels >= 6 && panels <= 14) {
      cashPrice += 3350;
      ccPrice += 3350;
      // Updated: Use 8kWac for smaller systems on 3-phase, not 10kWac
      inverterSize = "8 kWac Three Phase"; 
    } else if (panels >= 15 && panels <= 22) {
      cashPrice += 1600;
      ccPrice += 1600;
      // Updated: Use 8kWac for smaller systems on 3-phase, not 10kWac
      inverterSize = "8 kWac Three Phase";
    }
    // For p >= 23, it's already Three Phase in constant DB, no adjustment needed.
  }

  const batCash = batteries * BATTERY_COST_CASH;
  const batCC = batteries * BATTERY_COST_CC;

  return {
    cash: cashPrice + batCash,
    cc: ccPrice + batCC,
    inverterSize,
    tier
  };
};
